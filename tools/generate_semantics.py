#!/usr/bin/env python3
"""
Gerador de Semantics e Constantes Maestro a partir de arquivos ARB.

Este script lê o arquivo ARB template (app_en.arb) e gera:
1. lib/core/semantics/app_semantics.dart - Constantes Dart para Semantics
2. maestro_flows/constants.yaml - Variáveis de ambiente para Maestro

Uso:
    python3 tools/generate_semantics.py
"""

import json
import os
import re
from pathlib import Path
from typing import Dict, List


class SemanticsGenerator:
    """Gerador de constantes Semantics e variáveis Maestro a partir de ARB."""

    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.arb_dir = project_root / "lib" / "l10n"
        self.template_arb = self.arb_dir / "app_en.arb"
        self.semantics_output = project_root / "lib" / "core" / "semantics" / "app_semantics.dart"
        self.maestro_output = project_root / "maestro_flows" / "constants.yaml"

    def snake_to_camel(self, snake_str: str) -> str:
        """Converte snake_case para camelCase."""
        components = snake_str.split('_')
        return components[0] + ''.join(x.title() for x in components[1:])

    def snake_to_upper_snake(self, snake_str: str) -> str:
        """Converte snake_case para UPPER_SNAKE_CASE."""
        return snake_str.upper()

    def extract_keys_from_arb(self) -> List[str]:
        """Extrai todas as keys do arquivo ARB template (ignorando metadados)."""
        if not self.template_arb.exists():
            raise FileNotFoundError(f"Template ARB not found: {self.template_arb}")

        with open(self.template_arb, 'r', encoding='utf-8') as f:
            arb_data = json.load(f)

        # Filtrar apenas keys que NÃO começam com @ ou @@
        keys = [key for key in arb_data.keys() if not key.startswith('@')]
        keys.sort()  # Ordenar para consistência
        return keys

    def generate_dart_semantics(self, keys: List[str]) -> str:
        """Gera o arquivo Dart com constantes de Semantics."""
        lines = [
            "// GENERATED CODE - DO NOT MODIFY BY HAND",
            "// Generated by: tools/generate_semantics.py",
            "// Source: lib/l10n/app_en.arb",
            "",
            "/// Identificadores de Semantics gerados a partir das keys do ARB.",
            "///",
            "/// Estes identificadores são usados para testes E2E e acessibilidade.",
            "/// NUNCA modifique este arquivo manualmente. Edite o ARB e regenere.",
            "class AppSemantics {",
            "  AppSemantics._(); // Private constructor to prevent instantiation",
            "",
        ]

        for key in keys:
            camel_key = self.snake_to_camel(key)
            lines.append(f"  /// Identifier for: {key}")
            lines.append(f"  static const String {camel_key} = '{key}';")
            lines.append("")

        lines.append("}")
        lines.append("")  # Final newline

        return "\n".join(lines)

    def generate_maestro_constants(self, keys: List[str]) -> str:
        """Gera o arquivo YAML com variáveis de ambiente para Maestro."""
        lines = [
            "# GENERATED CODE - DO NOT MODIFY BY HAND",
            "# Generated by: tools/generate_semantics.py",
            "# Source: lib/l10n/app_en.arb",
            "",
            "# Variáveis de ambiente para testes Maestro",
            "# Use nas flows como: ${VARIABLE_NAME}",
            "",
            "env:",
        ]

        for key in keys:
            upper_key = self.snake_to_upper_snake(key)
            lines.append(f"  {upper_key}: {key}")

        lines.append("")  # Final newline

        return "\n".join(lines)

    def write_file(self, file_path: Path, content: str):
        """Escreve conteúdo em arquivo, criando diretórios se necessário."""
        file_path.parent.mkdir(parents=True, exist_ok=True)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"✓ Generated: {file_path.relative_to(self.project_root)}")

    def generate(self):
        """Executa o processo de geração completo."""
        print("=" * 60)
        print("Semantics & Maestro Constants Generator")
        print("=" * 60)
        print()

        # 1. Extrair keys do ARB
        print(f"Reading ARB template: {self.template_arb.relative_to(self.project_root)}")
        keys = self.extract_keys_from_arb()
        print(f"Found {len(keys)} keys")
        print()

        # 2. Gerar AppSemantics
        print("Generating Dart semantics...")
        dart_content = self.generate_dart_semantics(keys)
        self.write_file(self.semantics_output, dart_content)
        print()

        # 3. Gerar Maestro constants
        print("Generating Maestro constants...")
        yaml_content = self.generate_maestro_constants(keys)
        self.write_file(self.maestro_output, yaml_content)
        print()

        # 4. Resumo
        print("=" * 60)
        print("Generation Summary")
        print("=" * 60)
        print(f"Total keys processed: {len(keys)}")
        print()
        print("Generated files:")
        print(f"  • {self.semantics_output.relative_to(self.project_root)}")
        print(f"  • {self.maestro_output.relative_to(self.project_root)}")
        print()
        print("Next steps:")
        print("  1. Run: flutter gen-l10n")
        print("  2. Import in widgets: import 'package:maestro_test/core/semantics/app_semantics.dart';")
        print("  3. Use in Maestro flows: ${CONSTANT_NAME}")
        print()
        print("✓ Generation complete!")
        print()


def main():
    """Entry point do script."""
    # Detectar raiz do projeto (onde está pubspec.yaml)
    script_dir = Path(__file__).parent
    project_root = script_dir.parent

    if not (project_root / "pubspec.yaml").exists():
        print("ERROR: pubspec.yaml not found. Run this script from the project root.")
        exit(1)

    generator = SemanticsGenerator(project_root)

    try:
        generator.generate()
    except FileNotFoundError as e:
        print(f"ERROR: {e}")
        print()
        print("Make sure you have created the ARB template file:")
        print("  lib/l10n/app_en.arb")
        exit(1)
    except Exception as e:
        print(f"ERROR: Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        exit(1)


if __name__ == "__main__":
    main()
